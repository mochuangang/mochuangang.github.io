<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          [Linux] linux基础之（十四）进程管理 - 莫传刚 | Blog
        
    </title>

    <link rel="canonical" href="http://www.mochuangang.com/article/Linux/14.Linux之进程管理/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/article_header/linux.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                            
                        </div>
                        <h1>[Linux] linux基础之（十四）进程管理</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by 莫传刚 on
                            2018-06-22
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">莫传刚</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <ul>
<li>[2.监控进程状态]</li>
<li>[3.管理进程状态]</li>
<li>[4.管理后台进程]</li>
<li>[5.进程的优先级[进阶]]</li>
<li>[6.系统平均负载[进阶]]</li>
</ul>
<p>*<strong>1.什么是进程*</strong><br>
<em>比如: 开发写的代码我们称为程序，那么将开发的代码运行起来。我们称为进程。<br>
总结一句话就是: 当我们运行一个程序，那么我们将运行的程序叫进程。<br>
PS1: 当程序运行为进程后，系统会为该进程分配内存，以及进程运行的身份和权限。<br>
PS2: 在进程运行的过程中，系统会有各种指标来表示当前运行的状态。</em></p>
<p>*<strong>2.程序和进程的区别*</strong><br>
<em>1.程序是数据和指令的集合，是一个静态的概念。比如/bin/ls、/bin/cp等二进制文件。同时程序可以长期存在系统中。<br>
2.进程是程序运行的过程，是一个动态的概念。进程是存在生命周期的概念的，也就是说进程会随着程序的终止而销毁，不会永久存在系统中。</em></p>
<p>*<strong>3.进程的生命周期*</strong><br>
<em>生命周期就是指一个对象的生老病死。用处很广。</em></p>
<p><img src="http://cdn.xuliangwei.com/15203273556568.jpg" alt="img"></p>
<p><em>当父进程接收到任务调度时，会通过fock派生子进程来处理，那么子进程会继承父进程属性。<br>
1.子进程在处理任务代码时，父进程会进入等待状态中…<br>
2.子进程在处理任务代码后，会执行退出，然后唤醒父进程来回收子进程的资源。<br>
3.如果子进程在处理任务过程中，父进程退出了，子进程没有退出，那么这些子进程就没有父进程来管理了，就变成僵尸进程。<br>
PS: 每个进程都父进程的PPID，子进程则叫PID。</em></p>
<p><em>例: 假设现在我是蒋先生(system进程)…故事持续中…</em></p>
<h2 id="2监控进程状态">2.监控进程状态</h2>
<p><em>程序在运行后，我们需要了解进程的运行状态。查看进程的状态分为: 静态和动态两种方式</em></p>
<p>*<strong>1.使用ps命令查看当前的进程状态(静态)*</strong><br>
<em>1)示例、ps -aux常用组合，查看进程 用户、PID、占用cpu百分比、占用内存百分比、状态、执行的命令等</em></p>
<p><img src="http://cdn.xuliangwei.com/15563557501193.jpg" alt="img"></p>
<table>
<thead>
<tr>
<th style="text-align:left">状态</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">USER</td>
<td style="text-align:left">启动进程的用户</td>
</tr>
<tr>
<td style="text-align:left">PID</td>
<td style="text-align:left">进程运行的ID号</td>
</tr>
<tr>
<td style="text-align:left">%CPU</td>
<td style="text-align:left">进程占用CPU百分比</td>
</tr>
<tr>
<td style="text-align:left">%MEM</td>
<td style="text-align:left">进程占用内存百分比</td>
</tr>
<tr>
<td style="text-align:left">VSZ</td>
<td style="text-align:left">进程占用虚拟内存大小 (单位KB)</td>
</tr>
<tr>
<td style="text-align:left">RSS</td>
<td style="text-align:left">进程占用物理内存实际大小 (单位KB)</td>
</tr>
<tr>
<td style="text-align:left">TTY</td>
<td style="text-align:left">进程是由哪个终端运行启动的tty1、pts/0等 ?表示内核程序与终端无关</td>
</tr>
<tr>
<td style="text-align:left">STAT</td>
<td style="text-align:left">进程运行过程中的状态 man ps （/STATE）</td>
</tr>
<tr>
<td style="text-align:left">START</td>
<td style="text-align:left">进程的启动时间</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">进程占用 CPU 的总时间(为0表示还没超过秒)</td>
</tr>
<tr>
<td style="text-align:left">COMMAND</td>
<td style="text-align:left">程序的运行指令，[ 方括号 ] 属于内核态的进程。 没有 [ ] 的是用户态进程。</td>
</tr>
</tbody>
</table>
<p><em>2.STAT状态的S、Ss、S+、R、R、S+等等，都是什么意思?</em><br>
<img src="http://cdn.xuliangwei.com/15563560032039.jpg" alt="img"></p>
<table>
<thead>
<tr>
<th style="text-align:left">STAT基本状态</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">STAT状态+符号</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">R</td>
<td style="text-align:left">进程运行</td>
<td style="text-align:left">s</td>
<td style="text-align:left">进程是控制进程， Ss进程的领导者，父进程</td>
</tr>
<tr>
<td style="text-align:left">S</td>
<td style="text-align:left">可中断睡眠</td>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">进程运行在高优先级上，S&lt;优先级较高的进程</td>
</tr>
<tr>
<td style="text-align:left">T</td>
<td style="text-align:left">进程被暂停</td>
<td style="text-align:left">N</td>
<td style="text-align:left">进程运行在低优先级上，SN优先级较低的进程</td>
</tr>
<tr>
<td style="text-align:left">D</td>
<td style="text-align:left">不可中断睡眠</td>
<td style="text-align:left">+</td>
<td style="text-align:left">当前进程运行在前台，R+该表示进程在前台运行</td>
</tr>
<tr>
<td style="text-align:left">Z</td>
<td style="text-align:left">僵尸进程</td>
<td style="text-align:left">l</td>
<td style="text-align:left">进程是多线程的，Sl表示进程是以线程方式运行</td>
</tr>
</tbody>
</table>
<p><em>案例一、PS命令查看进程状态切换</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.在终端1上运行vim</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># vim oldboy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.在终端2上运行ps命令查看状态</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># ps aux|grep oldboy    #S表示睡眠模式，+表示前台运行</span></span><br><span class="line">root      58118  0.4  0.2 151788  5320 pts/1    S+   22:11   0:00 oldboy</span><br><span class="line">root      58120  0.0  0.0 112720   996 pts/0    R+   22:12   0:00 grep --color=auto oldboy</span><br><span class="line"><span class="comment">#在终端1上挂起vim命令，按下：ctrl+z </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.回到终端2再次运行ps命令查看状态</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># ps aux|grep oldboy    #T表示停止状态</span></span><br><span class="line">root      58118  0.1  0.2 151788  5320 pts/1    T    22:11   0:00 vim oldboy</span><br><span class="line">root      58125  0.0  0.0 112720   996 pts/0    R+   22:12   0:00 grep --color=auto oldboy</span><br></pre></td></tr></table></figure>
<p><em>案例二、PS命令查看不可中断状态进程</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.使用tar打包文件时，可以通过终端不断查看状态，由S+，R+变为D+</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># tar -czf etc.tar.gz /etc/ /usr/ /var/</span></span><br><span class="line"></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># ps aux|grep tar|grep -v grep</span></span><br><span class="line">root      58467  5.5  0.2 127924  5456 pts/1    R+   22:22   0:04 tar -czf etc.tar.gz /etc/ </span><br><span class="line">[root@xuliangwei ~]<span class="comment"># ps aux|grep tar|grep -v grep</span></span><br><span class="line">root      58467  5.5  0.2 127088  4708 pts/1    S+   22:22   0:03 tar -czf etc.tar.gz /etc/ </span><br><span class="line">[root@xuliangwei ~]<span class="comment"># ps aux|grep tar|grep -v grep</span></span><br><span class="line">root      58467  5.6  0.2 127232  4708 pts/1    D+   22:22   0:03 tar -czf etc.tar.gz /etc/</span><br></pre></td></tr></table></figure>
<p>*<strong>2.使用top命令查看当前的进程状态(动态)*</strong></p>
<p><img src="http://cdn.xuliangwei.com/15565025372082.jpg" alt="img"></p>
<table>
<thead>
<tr>
<th style="text-align:left">任务</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Tasks: 129 total</td>
<td style="text-align:left">当然进程的总数</td>
</tr>
<tr>
<td style="text-align:left">1 running</td>
<td style="text-align:left">正在运行的进程数</td>
</tr>
<tr>
<td style="text-align:left">128 sleeping</td>
<td style="text-align:left">睡眠的进程数</td>
</tr>
<tr>
<td style="text-align:left">0 stopped</td>
<td style="text-align:left">停止的进程数</td>
</tr>
<tr>
<td style="text-align:left">0 zombie</td>
<td style="text-align:left">僵尸进程数</td>
</tr>
<tr>
<td style="text-align:left">%Cpu(s): 0.7 us</td>
<td style="text-align:left">系统用户进程使用CPU百分比</td>
</tr>
<tr>
<td style="text-align:left">0.7 sy</td>
<td style="text-align:left">内核中的进程占用CPU百分比，通常内核是于硬件进行交互</td>
</tr>
<tr>
<td style="text-align:left">98.7 id</td>
<td style="text-align:left">空闲CPU的百分比</td>
</tr>
<tr>
<td style="text-align:left">0.0 wa</td>
<td style="text-align:left">CPU等待IO完成的时间</td>
</tr>
<tr>
<td style="text-align:left">0.0 hi</td>
<td style="text-align:left">硬中断，占的CPU百分比</td>
</tr>
<tr>
<td style="text-align:left">0.0 si</td>
<td style="text-align:left">软中断，占的CPU百分比</td>
</tr>
<tr>
<td style="text-align:left">0.0 st</td>
<td style="text-align:left">比如虚拟机占用物理CPU的时间</td>
</tr>
</tbody>
</table>
<p>*<strong><a href="https://www.cnblogs.com/xuliangwei/p/10789270.html" target="_blank" rel="noopener">PS: 如何理解中断这个东西</a>*</strong></p>
<p><em>top 常见指令</em></p>
<table>
<thead>
<tr>
<th style="text-align:left">字母</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">h</td>
<td style="text-align:left">查看帮出</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">数字1，显示所有CPU核心的负载</td>
</tr>
<tr>
<td style="text-align:left">z</td>
<td style="text-align:left">以高亮显示数据</td>
</tr>
<tr>
<td style="text-align:left">b</td>
<td style="text-align:left">高亮显示处于R状态的进程</td>
</tr>
<tr>
<td style="text-align:left">M</td>
<td style="text-align:left">按内存使用百分比排序输出</td>
</tr>
<tr>
<td style="text-align:left">P</td>
<td style="text-align:left">按CPU使用百分比排序输出</td>
</tr>
<tr>
<td style="text-align:left">q</td>
<td style="text-align:left">退出top</td>
</tr>
</tbody>
</table>
<h2 id="3管理进程状态">3.管理进程状态</h2>
<p><em>当程序运行为进程后，如果希望停止进程，怎么办呢? 那么此时我们可以使用linux的kill命令对进程发送关闭信号。当然除了kill、还有killall，pkill</em></p>
<p><em>1.使用kill -l列出当前系统所支持的信号</em><br>
<img src="http://cdn.xuliangwei.com/15564395615195.jpg" alt="img"><br>
<em>虽然linux支持信号很多，但是我们仅列出我们最为常用的3个信号</em></p>
<table>
<thead>
<tr>
<th style="text-align:left">数字编号</th>
<th style="text-align:left">信号含义</th>
<th style="text-align:left">信号翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">SIGHUP</td>
<td style="text-align:left">通常用来重新加载配置文件</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">SIGKILL</td>
<td style="text-align:left">强制杀死进程</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left">SIGTERM</td>
<td style="text-align:left">终止进程，默认kill使用该信号</td>
</tr>
</tbody>
</table>
<p><em>1.我们使用kill命令杀死指定PID的进程。</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.给 vsftpd 进程发送信号 1,15</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># yum -y install vsftpd</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># systemctl start vsftpd</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># ps aux|grep vsftpd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.发送重载信号，例如 vsftpd 的配置文件发生改变，希望重新加载</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># kill -1 9160</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.发送停止信号，当然vsftpd 服务有停止的脚本 systemctl stop vsftpd</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># kill 9160</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.发送强制停止信号，当无法停止服务时，可强制终止信号</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># kill -9 9160</span></span><br></pre></td></tr></table></figure>
<p><em>2.Linux系统中的killall、pkill命令用于杀死指定名字的进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall、pkill把这两个过程合二为一，是一个很好用的命令。</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例1、通过服务名称杀掉进程</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># pkill nginx</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># killall nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例2、使用pkill踢出从远程登录到本机的用户，终止pts/0上所有进程, 并且bash也结束（用户被强制退出）</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># pkill -9 -t pts/0</span></span><br></pre></td></tr></table></figure>
<h2 id="4管理后台进程">4.管理后台进程</h2>
<p>*<strong>1.什么是后台进程*</strong><br>
<em>通常进程都会在终端前台运行，一旦关闭终端，进程也会随着结束，那么此时我们就希望进程能在后台运行，就是将在前台运行的进程放入后台运行，这样及时我们关闭了终端也不影响进程的正常运行。</em></p>
<p>*<strong>2.我们为什么要将进程放入后台运行*</strong><br>
<em>比如：我们此前在国内服务器往国外服务器传输大文件时，由于网络的问题需要传输很久，如果在传输的过程中出现网络抖动或者不小心关闭了终端则会导致传输失败，如果能将传输的进程放入后台，是不是就能解决此类问题了。</em></p>
<p>*<strong>3.使用什么工具将进程放入后台*</strong><br>
<em>早期的时候大家都选择使用&amp;符号将进程放入后台，然后在使用jobs、bg、fg等方式查看进程状态，但太麻烦了。也不直观，所以我们推荐使用screen。</em></p>
<p><em>1.jobs、bg、fg的使用(强烈不推荐，了解即可)</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@xuliangwei ~]<span class="comment"># sleep 3000 &amp; //运行程序(时)，让其在后台执行 </span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># sleep 4000 //^Z,将前台的程序挂起(暂停)到后台 </span></span><br><span class="line">[2]+ Stopped sleep 4000</span><br><span class="line">[root@xuliangwei ~]<span class="comment"># ps aux |grep sleep</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># jobs  //查看后台作业</span></span><br><span class="line">[1]- Running sleep 3000 &amp; </span><br><span class="line">[2]+ Stopped sleep 4000</span><br><span class="line"></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># bg %2     //让作业 2 在后台运行</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># fg %1     //将作业 1 调回到前台</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># kill %1   //kill 1，终止 PID 为 1 的进程</span></span><br><span class="line"></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># (while :; do date; sleep 2; done) &amp; //进程在后台运行，但输出依然在当前终端</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># (while :; do date; sleep 2; done) &amp;&gt;/dev/null &amp;</span></span><br></pre></td></tr></table></figure>
<p><em>2.screen的使用(强烈推荐，生产必用)</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.安装</span></span><br><span class="line">[root@oldboy ~]<span class="comment"># yum install screen -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.开启一个screen窗口,指定名称</span></span><br><span class="line">[root@oldboy ~]<span class="comment"># screen -S wget_mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.在screen窗口中执行任务即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.平滑的退出screen,但不会终止screen中的任务。注意: 如果使用exit 才算真的关闭screen窗口</span></span><br><span class="line">ctrl+a+d</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.查看当前正在运行的screen有哪些</span></span><br><span class="line">[root@oldboy ~]<span class="comment"># screen -list</span></span><br><span class="line">There is a screen on:</span><br><span class="line">    22058.wget_mysql    (Detached)</span><br><span class="line">1 Socket <span class="keyword">in</span> /var/run/screen/S-root.</span><br><span class="line"></span><br><span class="line"><span class="comment">#6.进入正在运行的screen</span></span><br><span class="line">[root@oldboy ~]<span class="comment"># screen -r wget_mysql</span></span><br><span class="line">[root@oldboy ~]<span class="comment"># screen -r 22058</span></span><br></pre></td></tr></table></figure>
<h2 id="5进程的优先级进阶">5.进程的优先级[进阶]</h2>
<p>*<strong>1.什么优先级*</strong><br>
<em>优先级指的是优先享受资源，比如排队买票时，军人优先、老人优先。等等</em></p>
<p>*<strong>2.为什么要有系统优先级*</strong><br>
<em>举个例子: 海底捞火锅正常情况下响应就特别快，那么当节假日来临时人员突增则会导致处理请求特别慢，那么假设我是海底捞VIP客户(最高优先级)，无论门店多么繁忙，我都不用排队，海底捞人员会直接服务于我，满足我的需求。至于没有VIP的人员(较低优先级)则进入排队等待状态。(PS: 至于等多久，那…)</em></p>
<p>*<strong>3.系统中如何给进程配置优先级?*</strong><br>
<em>在启动进程时，为不同的进程使用不同的调度策略。<br>
nice 值越高： 表示优先级越低，例如+19，该进程容易将CPU 使用量让给其他进程。<br>
nice 值越低： 表示优先级越高，例如-20，该进程更不倾向于让出CPU。</em></p>
<p><em>1) 使用top或ps命令查看进程的优先级</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.使用top可以查看nice优先级。  NI: 实际nice级别，默认是0。 PR: 显示nice值，-20映射到0，+19映射到39</span></span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">1083 root      20   0  298628   2808   1544 S  0.3  0.1   2:49.28 vmtoolsd</span><br><span class="line">5    root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:+</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用ps查看进程优先级</span></span><br><span class="line">[root@m01 ~]<span class="comment"># ps axo command,nice |grep sshd|grep -v grep</span></span><br><span class="line">/usr/sbin/sshd -D             0</span><br><span class="line">sshd: root@pts/2              0</span><br></pre></td></tr></table></figure>
<p><em>2) nice指定程序的优先级。语法格式 nice -n 优先级数字 进程名称</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.开启vim并且指定程序优先级为-5</span></span><br><span class="line">[root@m01 ~]<span class="comment"># nice -n -5 vim &amp;</span></span><br><span class="line">[1] 98417</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.查看该进程的优先级情况</span></span><br><span class="line">[root@m01 ~]<span class="comment"># ps axo pid,command,nice |grep 98417</span></span><br><span class="line"> 98417 vim                         -5</span><br></pre></td></tr></table></figure>
<p><em>3) renice命令修改一个正在运行的进程优先级。语法格式 renice -n 优先级数字 进程pid</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.查看sshd进程当前的优先级状态</span></span><br><span class="line">[root@m01 ~]<span class="comment"># ps axo pid,command,nice |grep 折叠shd</span></span><br><span class="line"> 70840 sshd: root@pts/2              0</span><br><span class="line"> 98002 /usr/sbin/sshd -D             0</span><br><span class="line"> </span><br><span class="line"><span class="comment">#2.调整sshd主进程的优先级</span></span><br><span class="line">[root@m01 ~]<span class="comment"># renice -n -20 98002</span></span><br><span class="line">98002 (process ID) old priority 0, new priority -20</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.调整之后记得退出终端</span></span><br><span class="line">[root@m01 ~]<span class="comment"># ps axo pid,command,nice |grep 折叠shd</span></span><br><span class="line"> 70840 sshd: root@pts/2              0</span><br><span class="line"> 98002 /usr/sbin/sshd -D           -20</span><br><span class="line">[root@m01 ~]<span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.当再次登陆sshd服务，会由主进程fork子进程(那么子进程会继承主进程的优先级)</span></span><br><span class="line">[root@m01 ~]<span class="comment"># ps axo pid,command,nice |grep 折叠shd</span></span><br><span class="line"> 98002 /usr/sbin/sshd -D           -20</span><br><span class="line"> 98122 sshd: root@pts/0            -20</span><br></pre></td></tr></table></figure>
<p>*<strong><a href="https://www.xuliangwei.com/bgx/1337.html" target="_blank" rel="noopener">生产案例、Linux出现假死，怎么办，又如何通过nice解决？</a>*</strong></p>
<h2 id="6系统平均负载进阶">6.系统平均负载[进阶]</h2>
<p><em>每次发现系统变慢时，我们通常做的第一件事，就是执行 top 或者 uptime 命令，来了解系统的负载情况。比如像下面这样，我在命令行里输入了 uptime 命令，系统也随即给出了结果。</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># uptime</span></span><br><span class="line"> 04:49:26 up 2 days,  2:33,  2 users,  load average: 0.70, 0.04, 0.05</span><br><span class="line"><span class="comment">#我们已经比较熟悉前面几列，它们分别是当前时间、系统运行时间以及正在登录用户数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 而最后三个数字呢，依次则是过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）。</span></span><br></pre></td></tr></table></figure>
<p>*<strong>1.什么是平均负载*</strong><br>
<em>平均负载不就是单位时间内的 CPU 使用率吗？上面的 0.70，就代表 CPU 使用率是 70%。其实上并…<br>
那到底如何理解平均负载:</em> *<strong>平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，*</strong> <em>PS: 平均负载与 CPU 使用率并没有直接关系。</em></p>
<p>*<strong>2.可运行状态和不可中断状态是什么*</strong><br>
*1.可运行状态进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们ps 命令看到处于 R 状态的进程。<br>
2.不可中断进程，(你做什么事情的时候是不能打断的?) 系统中最常见的是等待硬件设备的 I/O 响应，也就是我们 ps 命令中看到的 D 状态（也称为 Disk Sleep）的进程。<br>
例如: 当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。**<strong>所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。*</strong></p>
<p>*<strong>划重点，因此你可以简单理解为，平均负载其实就是单位时间内的活跃进程数。*</strong></p>
<p>*<strong>3.那平均负载为多少时合理*</strong><br>
<em>最理想的状态是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。所以在评判平均负载时，首先你要知道系统有几个 CPU，这可以通过 top 命令获取，或<code>grep 'model name' /proc/cpuinfo</code></em></p>
<p><em>例1、假设现在在 4、2、1核的CPU上，如果平均负载为 2 时，意味着什么呢？<br>
Q1.在4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。<br>
Q2.在2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。<br>
Q3.而1 个 CPU 的系统上，则意味着有一半的进程竞争不到 CPU。</em></p>
<p>*<strong>PS: 平均负载有三个数值，我们应该关注哪个呢?*</strong><br>
<em>实际上，我们都需要关注。就好比上海4月的天气，如果只看晚上天气，感觉在过冬天呢。但如果你结合了早上、中午、晚上三个时间点的温度来看，基本就可以全方位了解这一天的天气情况了。</em></p>
<p><em>1.如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。<br>
2.但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。<br>
3.反过来，如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续上升，所以就需要持续观察。<br>
PS: 一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析问题，并要想办法优化了</em></p>
<p><em>在来看个例子3、假设我们在有2个 CPU 系统上看到平均负载为 2.73，6.90，12.98<br>
那么说明在过去1 分钟内，系统有 136% 的超载 (2.73/2=136%)<br>
而在过去 5 分钟内，有 345% 的超载 (6.90/2=345%)<br>
而在过去15 分钟内，有 649% 的超载，(12.98/2=649%)<br>
但从整体趋势来看，系统的负载是在逐步的降低。</em></p>
<p>*<strong>4.那么在实际生产环境中，平均负载多高时，需要我们重点关注呢？*</strong><br>
<em>当平均负载高于 CPU 数量 70% 的时候，你就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。<br>
但 70% 这个数字并不是绝对的，最推荐的方法，还是把系统的平均负载监控起来，然后根据更多的历史数据，判断负载的变化趋势。当发现负载有明显升高趋势时，比如说负载翻倍了，你再去做分析和调查。</em></p>
<p>*<strong>5.平均负载与 CPU 使用率有什么关系*</strong><br>
<em>在实际工作中，我们经常容易把平均负载和 CPU 使用率混淆，所以在这里，我也做一个区分。可能你会疑惑，既然平均负载代表的是活跃进程数，那平均负载高了，不就意味着 CPU 使用率高吗？<br>
我们还是要回到平均负载的含义上来，平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。</em></p>
<p><em>而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：<br>
CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；<br>
I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；<br>
大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</em></p>
<p>*<strong>6.平均负载案例分析实战*</strong><br>
<em>下面，我们以三个示例分别来看这三种情况，并用 stress、mpstat、pidstat 等工具，找出平均负载升高的根源。<br>
stress 是 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。<br>
mpstat 是多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。<br>
pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果出现无法使用mpstat、pidstat命令查看%wait指标建议更新下软件包</span></span><br><span class="line">wget http://pagesperso-orange.fr/sebastien.godard/sysstat-11.7.3-1.x86_64.rpm</span><br><span class="line">rpm -Uvh sysstat-11.7.3-1.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>*<strong>场景一：CPU 密集型进程*</strong></p>
<p><em>1.首先，我们在第一个终端运行 stress 命令，模拟一个 CPU 使用率 100% 的场景：</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># stress --cpu 1 --timeout 600</span></span><br></pre></td></tr></table></figure>
<p><em>2.接着，在第二个终端运行 uptime 查看平均负载的变化情况</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用watch -d 参数表示高亮显示变化的区域(注意负载会持续升高)</span></span><br><span class="line">[root@m01 ~]<span class="comment"># watch -d uptime</span></span><br><span class="line">17:27:44 up 2 days,  3:11,  3 users,  load average: 1.10, 0.30, 0.17</span><br></pre></td></tr></table></figure>
<p><em>3.最后，在第三个终端运行 mpstat 查看 CPU 使用率的变化情况</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据</span></span><br><span class="line">[root@m01 ~]<span class="comment"># mpstat -P ALL 5</span></span><br><span class="line">Linux 3.10.0-957.1.3.el7.x86_64 (m01)   2019年04月29日     _x86_64_    (1 CPU)</span><br><span class="line"></span><br><span class="line">17时32分03秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">17时32分08秒  all   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">17时32分08秒    0   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line"></span><br><span class="line"><span class="comment">#单核CPU所以只有一个all和0</span></span><br></pre></td></tr></table></figure>
<p><em>4.从终端二中可以看到，1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。那么，到底是哪个进程导致了 CPU 使用率为 100% 呢？可以使用 pidstat 来查询</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 5 秒后输出一组数据</span></span><br><span class="line">[root@m01 ~]<span class="comment"># pidstat -u 5 1</span></span><br><span class="line">Linux 3.10.0-957.1.3.el7.x86_64 (m01)   2019年04月29日     _x86_64_(1 CPU)</span><br><span class="line"></span><br><span class="line">17时33分21秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">17时33分26秒     0    110019   98.80    0.00    0.00   98.80     0  stress</span><br><span class="line"></span><br><span class="line"><span class="comment">#从这里可以明显看到，stress 进程的 CPU 使用率为 100%。</span></span><br></pre></td></tr></table></figure>
<p>*<strong>场景二：I/O 密集型进程*</strong></p>
<p><em>1.首先还是运行 stress 命令，但这次模拟 I/O 压力，即不停地执行 sync</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># stress  --io 1 --timeout 600s</span></span><br></pre></td></tr></table></figure>
<p><em>2.然后在第二个终端运行 uptime 查看平均负载的变化情况：</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># watch -d uptime</span></span><br><span class="line">18:43:51 up 2 days,  4:27,  3 users,  load average: 1.12, 0.65, 0.00</span><br></pre></td></tr></table></figure>
<p><em>3.最后第三个终端运行 mpstat 查看 CPU 使用率的变化情况：</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据</span></span><br><span class="line">[root@m01 ~]<span class="comment"># mpstat -P ALL 5</span></span><br><span class="line">Linux 3.10.0-693.2.2.el7.x86_64 (bgx.com)   2019年05月07日     _x86_64_    (1 CPU)</span><br><span class="line"></span><br><span class="line">14时20分07秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">14时20分12秒  all    0.20    0.00   82.45   17.35    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">14时20分12秒    0    0.20    0.00   82.45   17.35    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line"></span><br><span class="line"><span class="comment">#会发现cpu的与内核打交道的sys占用非常高</span></span><br></pre></td></tr></table></figure>
<p><em>4.那么到底是哪个进程，导致 iowait 这么高呢？我们还是用 pidstat 来查询</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 5 秒后输出一组数据，-u 表示 CPU 指标</span></span><br><span class="line">[root@m01 ~]<span class="comment"># pidstat -u 5 1</span></span><br><span class="line">Linux 3.10.0-957.1.3.el7.x86_64 (m01)   2019年04月29日     _x86_64_(1 CPU)</span><br><span class="line">18时29分37秒   UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">18时29分42秒     0    127259   32.60    0.20    0.00   67.20   32.80     0  stress</span><br><span class="line">18时29分42秒     0    127261    4.60   28.20    0.00   67.20   32.80     0  stress</span><br><span class="line">18时29分42秒     0    127262    4.20   28.60    0.00   67.20   32.80     0  stress</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以发现，还是 stress 进程导致的。</span></span><br></pre></td></tr></table></figure>
<p>*<strong>场景三：大量进程的场景*</strong><br>
<em>当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。</em></p>
<p><em>1.首先，我们还是使用 stress，但这次模拟的是 4 个进程</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># stress -c 4 --timeout 600</span></span><br></pre></td></tr></table></figure>
<p><em>2.由于系统只有 1 个 CPU，明显比 4 个进程要少得多，因而，系统的 CPU 处于严重过载状态</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># watch -d uptime</span></span><br><span class="line">19:11:07 up 2 days,  4:45,  3 users,  load average: 4.65, 2.65, 4.65</span><br></pre></td></tr></table></figure>
<p><em>3.然后，再运行 pidstat 来看一下进程的情况：</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 5 秒后输出一组数据</span></span><br><span class="line">[root@m01 ~]<span class="comment"># pidstat -u 5 1</span></span><br><span class="line">平均时间:   UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">平均时间:     0    130290   24.55    0.00    0.00   75.25   24.55     -  stress</span><br><span class="line">平均时间:     0    130291   24.95    0.00    0.00   75.25   24.95     -  stress</span><br><span class="line">平均时间:     0    130292   24.95    0.00    0.00   75.25   24.95     -  stress</span><br><span class="line">平均时间:     0    130293   24.75    0.00    0.00   74.65   24.75     -  stress</span><br></pre></td></tr></table></figure>
<p><em>可以看出，4 个进程在争抢 1 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。</em></p>
<p>*<strong>分析完这三个案例，我再来归纳一下平均负载与CPU*</strong><br>
<em>平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，我们并不能直接发现，到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：<br>
平均负载高有可能是 CPU 密集型进程导致的；<br>
平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；<br>
当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源</em></p>
<p>*<strong><a href="https://www.cnblogs.com/muahao/p/6346775.html" target="_blank" rel="noopener">stress工具使用参考</a>*</strong></p>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/Linux/15.Linux之系统服务/" data-toggle="tooltip" data-placement="top" title="[Linux] linux基础之（十五）系统服务">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/Linux/13.Linux之磁盘管理/" data-toggle="tooltip" data-placement="top" title="[Linux] linux基础之（十三）磁盘管理">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                    <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                    <!--  css & js -->
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2监控进程状态"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">2.&#x76D1;&#x63A7;&#x8FDB;&#x7A0B;&#x72B6;&#x6001;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3管理进程状态"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">3.&#x7BA1;&#x7406;&#x8FDB;&#x7A0B;&#x72B6;&#x6001;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4管理后台进程"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">4.&#x7BA1;&#x7406;&#x540E;&#x53F0;&#x8FDB;&#x7A0B;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5进程的优先级进阶"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">5.&#x8FDB;&#x7A0B;&#x7684;&#x4F18;&#x5148;&#x7EA7;[&#x8FDB;&#x9636;]</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6系统平均负载进阶"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">6.&#x7CFB;&#x7EDF;&#x5E73;&#x5747;&#x8D1F;&#x8F7D;[&#x8FDB;&#x9636;]</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'rz'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/mochuangang">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 莫传刚 2020 
                    By <a href="http://www.mochuangang.com">欢迎来搞</a> | BigData
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=mochuangang&repo=mochuangang.github.io
&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://www.mochuangang.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://www.mochuangang.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
