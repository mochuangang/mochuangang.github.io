<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          [Java] Java（十二）集合 - 莫传刚 | Blog
        
    </title>

    <link rel="canonical" href="http://www.mochuangang.com/article/Java/12集合/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/article_header/article_header.png')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Java" title="Java">Java</a>
                            
                        </div>
                        <h1>[Java] Java（十二）集合</h1>
                        <h2 class="subheading">Java基础.</h2>
                        <span class="meta">
                            Posted by 莫传刚 on
                            2020-03-12
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">莫传刚</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="第十二章-集合">第十二章 集合</h1>
<h2 id="121-概念">12.1 概念</h2>
<p>数据结构：存储数据的某种结构</p>
<p>（1）底层的物理结构</p>
<p>①数组：开辟连续的存储空间，每一个元素使用[下标]进行区别</p>
<p>②链式：不需要开辟连续的存储空间，但是需要“结点”来包装要存储的数据，结点包含两部分内容：</p>
<p>​	A、数据</p>
<p>​	B、记录其他结点的地址，例如：next，pre，left，right，parent等</p>
<p>（2）表现出来的逻辑结构：动态数组、单向链表、双向链表、队列、栈、二叉树、哈希表、图等</p>
<h2 id="122-手动实现一些逻辑结构">12.2 手动实现一些逻辑结构</h2>
<p>1、动态数组</p>
<p>包含：</p>
<p>（1）内部使用一个数组，用来存储数据</p>
<p>（2）内部使用一个total，记录实际存储的元素的个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span> </span>&#123;</span><br><span class="line">	<span class="comment">//为什么使用Object，因为只是说这个容器是用来装对象的，但是不知道用来装什么对象。</span></span><br><span class="line">	<span class="keyword">private</span> Object[] data;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">()</span></span>&#123;</span><br><span class="line">		data = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加一个元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="comment">//检查是否需要扩容</span></span><br><span class="line">		checkCapacity();</span><br><span class="line">		data[total++] = obj;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//如果data满了，就扩容为原来的2倍</span></span><br><span class="line">		<span class="keyword">if</span>(total &gt;= data.length)&#123;</span><br><span class="line">			data = Arrays.copyOf(data, data.length*<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回实际元素的个数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回数组的实际容量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data.length;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取[index]位置的元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">		<span class="comment">//校验index的合理性范围</span></span><br><span class="line">		checkIndex(index);</span><br><span class="line">		<span class="keyword">return</span> data[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=total)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(index+<span class="string">"对应位置的元素不存在"</span>);</span><br><span class="line"><span class="comment">//			throw new IndexOutOfBoundsException(index+"越界");</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//替换[index]位置的元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object value)</span></span>&#123;</span><br><span class="line">		<span class="comment">//校验index的合理性范围</span></span><br><span class="line">		checkIndex(index);</span><br><span class="line">		</span><br><span class="line">		data[index] = value;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//在[index]位置插入一个元素value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, Object value)</span></span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * (1)考虑下标的合理性</span></span><br><span class="line"><span class="comment">		 * (2)总长度是否够</span></span><br><span class="line"><span class="comment">		 * (3)[index]以及后面的元素往后移动，把[index]位置腾出来</span></span><br><span class="line"><span class="comment">		 * (4)data[index]=value  放入新元素</span></span><br><span class="line"><span class="comment">		 * (5)total++  有效元素的个数增加</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(1)考虑下标的合理性：校验index的合理性范围</span></span><br><span class="line">		checkIndex(index);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(2)总长度是否够：检查是否需要扩容</span></span><br><span class="line">		checkCapacity();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(3)[index]以及后面的元素往后移动，把[index]位置腾出来</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 假设total = 5, data.length= 10, index= 1</span></span><br><span class="line"><span class="comment">		 * 有效元素的下标[0,4]</span></span><br><span class="line"><span class="comment">		 * 移动：[1]-&gt;[2],[2]-&gt;[3],[3]-&gt;[4],[4]-&gt;[5]</span></span><br><span class="line"><span class="comment">		 * 移动元素的个数：total-index</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.arraycopy(data, index, data, index+<span class="number">1</span>, total-index);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(4)data[index]=value  放入新元素</span></span><br><span class="line">		data[index] = value;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(5)total++  有效元素的个数增加</span></span><br><span class="line">		total++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回所有实际存储的元素</span></span><br><span class="line">	<span class="keyword">public</span> Object[] getAll()&#123;</span><br><span class="line">		<span class="comment">//返回total个</span></span><br><span class="line">		<span class="keyword">return</span> Arrays.copyOf(data, total);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除[index]位置的元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * (1)校验index的合理性范围</span></span><br><span class="line"><span class="comment">		 * (2)移动元素，把[index+1]以及后面的元素往前移动</span></span><br><span class="line"><span class="comment">		 * (3)把data[total-1]=null  让垃圾回收器尽快回收</span></span><br><span class="line"><span class="comment">		 * (4)总元素个数减少 total--</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(1)考虑下标的合理性：校验index的合理性范围</span></span><br><span class="line">		checkIndex(index);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(2)移动元素，把[index+1]以及后面的元素往前移动</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 假设total=8, data.length=10, index = 3</span></span><br><span class="line"><span class="comment">		 * 有效元素的范围[0,7]</span></span><br><span class="line"><span class="comment">		 * 移动：[4]-&gt;[3],[5]-&gt;[4],[6]-&gt;[5],[7]-&gt;[6]</span></span><br><span class="line"><span class="comment">		 * 移动了4个：total-index-1</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.arraycopy(data, index+<span class="number">1</span>, data, index, total-index-<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(3)把data[total-1]=null  让垃圾回收器尽快回收</span></span><br><span class="line">		data[total-<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		(4)总元素个数减少 total--</span></span><br><span class="line">		total--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询某个元素的下标</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(data[i] == <span class="keyword">null</span>)&#123;<span class="comment">//等价于 if(data[i] == obj)</span></span><br><span class="line">					<span class="keyword">return</span> i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(obj.equals(data[i]))&#123;</span><br><span class="line">					<span class="keyword">return</span> i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除数组中的某个元素</span></span><br><span class="line">	<span class="comment">//如果有重复的，只删除第一个</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * (1)先查询obj的[index]</span></span><br><span class="line"><span class="comment">		 * (2)如果存在，就调用remove(index)删除就可以</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(1)先查询obj的[index]</span></span><br><span class="line">		<span class="keyword">int</span> index = indexOf(obj);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">			remove(index);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//不存在，可以什么也不做</span></span><br><span class="line">		<span class="comment">//不存在，也可以抛异常</span></span><br><span class="line">		<span class="comment">//throw new RuntimeException(obj + "不存在");</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object old, Object value)</span></span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * (1)查询old的[index]</span></span><br><span class="line"><span class="comment">		 * (2)如果存在，就调用set(index, value)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//		(1)查询old的[index]</span></span><br><span class="line">		<span class="keyword">int</span> index = indexOf(old);</span><br><span class="line">		<span class="keyword">if</span>(index!=-<span class="number">1</span>)&#123;</span><br><span class="line">			set(index, value);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//不存在，可以什么也不做</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、单向链表</p>
<p>包含：</p>
<p>（1）包含一个Node类型的成员变量first：用来记录第一个结点的地址</p>
<p>如果这个链表是空的，还没有任何结点，那么first是null。</p>
<p>最后一个结点的特征：就是它的next是null</p>
<p>（2）内部使用一个total，记录实际存储的元素的个数</p>
<p>（3）使用了一个内部类Node</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里不需要数组，不需要其他的复杂的结构，我只要记录单向链表的“头”结点</span></span><br><span class="line">	<span class="keyword">private</span> Node first;<span class="comment">//first中记录的是第一个结点的地址</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total;<span class="comment">//这里我记录total是为了后面处理的方便，例如：当用户获取链表有效元素的个数时，不用现数，而是直接返回total等</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 内部类，因为这种Node结点的类型，在别的地方没有用，只在单向链表中，用于存储和表示它的结点关系。</span></span><br><span class="line"><span class="comment">	 * 因为我这里涉及为内部类型。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">		Object data;<span class="comment">//因为数据可以是任意类型的对象，所以设计为Object</span></span><br><span class="line">		Node next;<span class="comment">//因为next中记录的下一个结点的地址，因此类型是结点类型</span></span><br><span class="line">		<span class="comment">//这里data,next没有私有化，是希望在外部类中可以不需要get/set，而是直接“结点对象.data","结点对象.next"使用</span></span><br><span class="line">		Node(Object data, Node next)&#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			<span class="keyword">this</span>.next = next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * (1)把obj的数据，包装成一个Node类型结点对象</span></span><br><span class="line"><span class="comment">		 * (2)把新结点“链接”当前链表的最后</span></span><br><span class="line"><span class="comment">		 * ①当前新结点是第一个结点</span></span><br><span class="line"><span class="comment">		 * 如何判断是否是第一个   if(first==null)说明暂时还没有第一个</span></span><br><span class="line"><span class="comment">		 * ②先找到目前的最后一个，把新结点链接到它的next中</span></span><br><span class="line"><span class="comment">		 * 如何判断是否是最后一个   if(某个结点.next == null)说明这个结点是最后一个</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"><span class="comment">//		(1)把obj的数据，包装成一个Node类型结点对象</span></span><br><span class="line">		<span class="comment">//这里新结点的next赋值为null，表示新结点是最后一个结点</span></span><br><span class="line">		Node newNode = <span class="keyword">new</span> Node(obj, <span class="keyword">null</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//①当前新结点是第一个结点</span></span><br><span class="line">		<span class="keyword">if</span>(first == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//说明newNode是第一个</span></span><br><span class="line">			first = newNode;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//②先找到目前的最后一个，把新结点链接到它的next中</span></span><br><span class="line">			Node node = first;</span><br><span class="line">			<span class="keyword">while</span>(node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">				node = node.next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//退出循环时node指向最后一个结点</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//把新结点链接到它的next中</span></span><br><span class="line">			node.next = newNode;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		total++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> Object[] getAll()&#123;</span><br><span class="line">		<span class="comment">//(1)创建一个数组，长度为total</span></span><br><span class="line">		Object[] all = <span class="keyword">new</span> Object[total];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(2)把单向链表的每一个结点中的data，拿过来放到all数组中</span></span><br><span class="line">		Node node = first;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="comment">//			all[i] = 结点.data;</span></span><br><span class="line">			all[i] = node.data;</span><br><span class="line">			<span class="comment">//然后node指向下一个</span></span><br><span class="line">			node = node.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(3)返回数组</span></span><br><span class="line">		<span class="keyword">return</span> all;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//(1)先考虑是否是第一个</span></span><br><span class="line">			<span class="keyword">if</span>(first!=<span class="keyword">null</span>)&#123;<span class="comment">//链表非空</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">//要删除的结点正好是第一个结点</span></span><br><span class="line">				<span class="keyword">if</span>(first.data == <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="comment">//让第一个结点指向它的下一个</span></span><br><span class="line">					first = first.next;</span><br><span class="line">					total--;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//要删除的不是第一个结点</span></span><br><span class="line">				Node node = first.next;<span class="comment">//第二个结点</span></span><br><span class="line">				Node last = first;</span><br><span class="line">				<span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//这里不包括最后一个，因为node.next==null，不进入循环，而node.next==null是最后一个</span></span><br><span class="line">					<span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line">						last.next = node.next;</span><br><span class="line">						total--;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					last = node;</span><br><span class="line">					node = node.next;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//单独判断最后一个是否是要删除的结点</span></span><br><span class="line">				<span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="comment">//要删除的是最后一个结点</span></span><br><span class="line">					last.next = <span class="keyword">null</span>;</span><br><span class="line">					total--;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//(1)先考虑是否是第一个</span></span><br><span class="line">			<span class="keyword">if</span>(first!=<span class="keyword">null</span>)&#123;<span class="comment">//链表非空</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">//要删除的结点正好是第一个结点</span></span><br><span class="line">				<span class="keyword">if</span>(obj.equals(first.data))&#123;</span><br><span class="line">					<span class="comment">//让第一个结点指向它的下一个</span></span><br><span class="line">					first = first.next;</span><br><span class="line">					total--;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//要删除的不是第一个结点</span></span><br><span class="line">				Node node = first.next;<span class="comment">//第二个结点</span></span><br><span class="line">				Node last = first;</span><br><span class="line">				<span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//这里不包括最后一个，因为node.next==null，不进入循环，而node.next==null是最后一个</span></span><br><span class="line">					<span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line">						last.next = node.next;</span><br><span class="line">						total--;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					last = node;</span><br><span class="line">					node = node.next;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//单独判断最后一个是否是要删除的结点</span></span><br><span class="line">				<span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line">					<span class="comment">//要删除的是最后一个结点</span></span><br><span class="line">					last.next = <span class="keyword">null</span>;</span><br><span class="line">					total--;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">			Node node = first;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="keyword">return</span> i;</span><br><span class="line">				&#125;</span><br><span class="line">				node = node.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			Node node = first;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line">					<span class="keyword">return</span> i;</span><br><span class="line">				&#125;</span><br><span class="line">				node = node.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="123-collection">12.3  Collection</h2>
<p>因为集合的类型很多，那么我们把它们称为集合框架。</p>
<p>集合框架分为两个家族：Collection（一组对象）和Map（一组映射关系、一组键值对）</p>
<h3 id="1231-collection">12.3.1 Collection</h3>
<p>Collection是代表一种对象的集合。它是Collection系列的根接口。</p>
<p>它们虽然：有些可能是有序的，有些可能是无序的，有些可能可以重复的，有些不能重复的，但是它们有共同的操作规范，因此这些操作的规范就抽象为了Collection接口。</p>
<p>常用方法：</p>
<p>（1）boolean add(Object obj)：添加一个</p>
<p>（2）boolean addAll（Collection c）：添加多个</p>
<p>（3）boolean remove(Object obj)：删除一个</p>
<p>（4）boolean removeAll(Collection c )： 删除多个</p>
<p>（5）boolean contains(Object c)：是否包含某个</p>
<p>（6）boolean containsAll(Collection c)： 是否包含所有</p>
<p>（7）boolean isEmpty()：是否为空</p>
<p>（8）int size()：获取元素个数</p>
<p>（9）void clear()：清空集合</p>
<p>（10）Object[] toArray()：获取所有元素</p>
<p>（11）Iterator iterator()： 获取遍历当前集合的迭代器对象</p>
<p>（12）retainAll(Collection c)：求当前集合与c集合的交集</p>
<h3 id="1232-collection系列的集合的遍历">12.3.2  Collection系列的集合的遍历</h3>
<p>1、明确使用Iterator迭代器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection c = ....;</span><br><span class="line"></span><br><span class="line">Iterator iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hashNext())&#123;</span><br><span class="line">    Object obj = iter.next();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Iterator 接口的方法：</p>
<p>（1）boolean hasNext()</p>
<p>（2）Object next()</p>
<p>（3）void remove()</p>
<p>2、foreach</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection c = ....;</span><br><span class="line"></span><br><span class="line">for(Object  obj :  c)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>什么样的集合（容器）能够使用foreach遍历？</p>
<p>（1）数组：</p>
<p>（2）实现了java.lang.Iterable接口</p>
<p>这个接口有一个抽象方法：Iterator iterator()</p>
<p>Iterator也是一个接口，它的实现类，通常在集合（容器）类中用内部类实现。并在iterator()的方法中创建它的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span> <span class="keyword">implements</span> <span class="title">Iterable</span></span>&#123;</span><br><span class="line">	<span class="comment">//为什么使用Object，因为只是说这个容器是用来装对象的，但是不知道用来装什么对象。</span></span><br><span class="line">	<span class="keyword">private</span> Object[] data;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//其他代码省略....</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyItr();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyItr</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> cursor;<span class="comment">//游标</span></span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> cursor!=total;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> data[cursor++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考：如果遍历数组，什么情况下选用foreach，什么情况下选用for循环？</p>
<p>当如果你的操作中涉及到[下标]操作时，用for最好。</p>
<p>当你只是查看元素的内容，那么选foreach更简洁一些。</p>
<p>思考：如果遍历Collection系列集合，什么情况下选用foreach，是否能选用for循环？</p>
<p>首先考虑使用foreach，如果该集合也有索引信息的话，也可以通过for来操作，如果没有下标的信息，就不要用for。即，如果该集合的物理结构是数组的，那么可以用for，如果物理结构是链式，那么使用下标操作效率很低。</p>
<p>思考：如果遍历Collection系列集合，什么情况下选用foreach，什么情况下使用Iterator？</p>
<p>如果只是查看集合的元素，使用foreach，代码会更简洁。</p>
<p>但是如果要涉及到在遍历集合的同时根据某种条件要删除元素等操作，那么选用Iterator。</p>
<h2 id="124-list">12.4 List</h2>
<h3 id="1241-list概述">12.4.1 List概述</h3>
<p>List：是Collection的子接口。</p>
<p>List系列的集合：有序的、可重复的</p>
<p>List系列的常用集合：ArrayList、Vector、LinkedList、Stack</p>
<h3 id="1242-list的api">12.4.2 List的API</h3>
<p>常用方法：</p>
<p>（1）boolean add(Object obj)：添加一个</p>
<p>（2）boolean addAll（Collection c）：添加多个</p>
<p>（3）void add(int index, Object obj)：添加一个，指定位置添加</p>
<p>（4）void addAll(int index, Collection c）：添加多个</p>
<p>（5）boolean remove(Object obj)：删除一个</p>
<p>（6）Object remove(int index)：删除指定位置的元素，并返回刚刚删除的元素</p>
<p>（7）boolean removeAll(Collection c )： 删除多个</p>
<p>（8）boolean contains(Object c)：是否包含某个</p>
<p>（9）boolean containsAll(Collection c)： 是否包含所有</p>
<p>（10）boolean isEmpty()：是否为空</p>
<p>（11）int size()：获取元素个数</p>
<p>（12）void clear()：清空集合</p>
<p>（13）Object[] toArray()：获取所有元素</p>
<p>（14）Iterator iterator()： 获取遍历当前集合的迭代器对象</p>
<p>（15）retainAll(Collection c)：求当前集合与c集合的交集</p>
<p>（16）ListIterator listIterator()：获取遍历当前集合的迭代器对象，这个迭代器可以往前、往后遍历</p>
<p>（17）ListIterator listIterator(int index)：从[index]位置开始，往前或往后遍历</p>
<p>（18）Object get(int index)：返回index位置的元素</p>
<p>（19）List  subList(int start, int end)：截取[start,end)部分的子列表</p>
<h3 id="1243-listiterator-接口">12.4.3 ListIterator 接口</h3>
<p>Iterator 接口的方法：</p>
<p>（1）boolean hasNext()</p>
<p>（2）Object next()</p>
<p>（3）void remove()</p>
<p>ListIterator 是 Iterator子接口：增加了如下方法</p>
<p>（4）void add(Object obj)</p>
<p>（5）void set(Object obj)</p>
<p>（6）boolean hasPrevious()</p>
<p>（7）Object previous()</p>
<p>（8）int nextIndex()</p>
<p>（9）int previousIndex()</p>
<h3 id="1244-list的实现类们的区别">12.4.4 List的实现类们的区别</h3>
<p>ArrayList、Vector、LinkedList、Stack</p>
<p>（1）ArrayList、Vector：都是动态数组</p>
<p>Vector是最早版本的动态数组，线程安全的，默认扩容机制是2倍，支持旧版的迭代器Enumeration</p>
<p>ArrayList是后增的动态数组，线程不安全的，默认扩容机制是1.5倍</p>
<p>（2）动态数组与LinkedList的区别</p>
<p>动态数组：底层物理结构是数组</p>
<p>​	优点：根据[下标]访问的速度很快</p>
<p>​	缺点：需要开辟连续的存储空间，而且需要扩容，移动元素等操作</p>
<p>LinkedList：底层物理结构是双向链表</p>
<p>​	优点：在增加、删除元素时，不需要移动元素，只需要修改前后元素的引用关系</p>
<p>​	缺点：我们查找元素时，只能从first或last开始查找</p>
<p>（3）Stack：栈</p>
<p>是Vector的子类。比Vector多了几个方法，能够表现出“先进后出或后进先出”的特点。</p>
<p>①Object peek()：访问栈顶元素</p>
<p>②Object pop()：弹出栈顶元素</p>
<p>③push()：把元素压入栈顶</p>
<p>（4）LinkedList可以作为很多种数据结构使用</p>
<p>单链表：只关注next就可以</p>
<p>队列：先进先出，找对应的方法</p>
<p>双端队列(JDK1.6加入)：两头都可以进出，找对应的方法</p>
<p>栈：先进后出，找对应的方法</p>
<p>建议：虽然LinkedList是支持对索引进行操作，因为它实现List接口的所有方法，但是我们不太建议调用类似这样的方法，因为效率比较低。</p>
<h3 id="1245-源码分析">12.4.5 源码分析</h3>
<h4 id="1vector">（1）Vector</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量initialCapacity为10</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);<span class="comment">//指定capacityIncrement增量为0</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement增量为<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">       <span class="comment">//判断了形参初始容量initialCapacity的合法性</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="comment">//创建了一个Object[]类型的数组</span></span><br><span class="line">       <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];<span class="comment">//默认是10</span></span><br><span class="line">       <span class="comment">//增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量</span></span><br><span class="line">       <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//synchronized意味着线程安全的   </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">    	<span class="comment">//看是否需要扩容</span></span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    	<span class="comment">//把新的元素存入[elementCount]，存入后，elementCount元素的个数增1</span></span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">//看是否超过了当前数组的容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);<span class="comment">//扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//获取目前数组的长度</span></span><br><span class="line">        <span class="comment">//如果capacityIncrement增量是0，新容量 = oldCapacity的2倍</span></span><br><span class="line">        <span class="comment">//如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量;</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果新容量超过了最大数组限制，那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把旧数组中的数据复制到新数组中，新数组的长度为newCapacity</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//查找obj在当前Vector中的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(obj);</span><br><span class="line">    <span class="comment">//如果i&gt;=0，说明存在，删除[i]位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;<span class="comment">//要查找的元素是null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)<span class="comment">//如果是null值，用==null判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//要查找的元素是非null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))<span class="comment">//如果是非null值，用equals判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//判断下标的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//j是要移动的元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果需要移动元素，就调用System.arraycopy进行移动</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//把index+1位置以及后面的元素往前移动</span></span><br><span class="line">        <span class="comment">//index+1的位置的元素移动到index位置，依次类推</span></span><br><span class="line">        <span class="comment">//一共移动j个</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素的总个数减少</span></span><br><span class="line">    elementCount--;</span><br><span class="line">    <span class="comment">//将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收</span></span><br><span class="line">    elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2arraylist源码分析">（2）ArrayList源码分析</h4>
<p>JDK1.6：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量为10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">      <span class="comment">//检查初始容量的合法性</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      <span class="comment">//数组初始化为长度为initialCapacity的数组</span></span><br><span class="line"><span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>JDK1.7</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//默认初始容量10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">       <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//数组初始化为一个空数组</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;<span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">           <span class="comment">//minCapacity按照 默认初始容量和minCapacity中的的最大值处理</span></span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//看是否需要扩容处理</span></span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>JDK1.8</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<span class="comment">//初始化为空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存入新元素到[size]位置，然后size自增1</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">//那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//查看是否需要扩容</span></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要的最小容量  比  当前数组的长度  大，即当前数组不够存，就扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//当前数组容量</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//新数组容量是旧数组容量的1.5倍</span></span><br><span class="line">        <span class="comment">//看旧数组的1.5倍是否够</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//看旧数组的1.5倍是否超过最大数组限制</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//复制一个新数组</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先找到o在当前ArrayList的数组中的下标</span></span><br><span class="line">    <span class="comment">//分o是否为空两种情况讨论</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;<span class="comment">//null值用==比较</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;<span class="comment">//非null值用equals比较</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">    <span class="comment">//需要移动的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">      modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素</span></span><br><span class="line">      E oldValue = elementData(index);</span><br><span class="line">      </span><br><span class="line"><span class="comment">//需要移动的元素个数</span></span><br><span class="line">      <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">      <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">      elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">//用element替换[index]位置的元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);<span class="comment">//返回[index]位置的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从前往后找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从后往前找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3linkedlist源码分析">（3）LinkedList源码分析</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">Node&lt;E&gt; first;<span class="comment">//记录第一个结点的位置</span></span><br><span class="line">Node&lt;E&gt; last;<span class="comment">//记录最后一个结点的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;<span class="comment">//元素数据</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//下一个结点</span></span><br><span class="line">        Node&lt;E&gt; prev;<span class="comment">//前一个结点</span></span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);<span class="comment">//默认把新元素链接到链表尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//用l 记录原来的最后一个结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//现在的新结点是最后一个结点了</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果l==null，说明原来的链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//那么新结点同时也是第一个结点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则把新结点链接到原来的最后一个结点的next中</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//元素个数增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//分o是否为空两种情况</span></span><br><span class="line">      <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//找到o对应的结点x</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">              <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//找到o对应的结点x</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">              <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                  unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;<span class="comment">//x是要被删除的结点</span></span><br><span class="line">      <span class="comment">// assert x != null;</span></span><br><span class="line">      <span class="keyword">final</span> E element = x.item;<span class="comment">//被删除结点的数据</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//被删除结点的下一个结点</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//被删除结点的上一个结点</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果被删除结点的前面没有结点，说明被删除结点是第一个结点</span></span><br><span class="line">      <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//那么被删除结点的下一个结点变为第一个结点</span></span><br><span class="line">          first = next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是第一个结点</span></span><br><span class="line">          <span class="comment">//被删除结点的上一个结点的next指向被删除结点的下一个结点</span></span><br><span class="line">          prev.next = next;</span><br><span class="line">          <span class="comment">//断开被删除结点与上一个结点的链接</span></span><br><span class="line">          x.prev = <span class="keyword">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果被删除结点的后面没有结点，说明被删除结点是最后一个结点</span></span><br><span class="line">      <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//那么被删除结点的上一个结点变为最后一个结点</span></span><br><span class="line">          last = prev;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是最后一个结点</span></span><br><span class="line">          <span class="comment">//被删除结点的下一个结点的prev执行被删除结点的上一个结点</span></span><br><span class="line">          next.prev = prev;</span><br><span class="line">          <span class="comment">//断开被删除结点与下一个结点的连接</span></span><br><span class="line">          x.next = <span class="keyword">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//把被删除结点的数据也置空，使得GC回收</span></span><br><span class="line">      x.item = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//元素个数减少</span></span><br><span class="line">      size--;</span><br><span class="line">      <span class="comment">//修改次数增加</span></span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="comment">//返回被删除结点的数据</span></span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="125-set">12.5 Set</h2>
<h3 id="1251-set概述">12.5.1 Set概述</h3>
<p>Set系列的集合：不可重复的</p>
<p>Set系列的集合，有有序的也有无序的。HashSet无序的，TreeSet按照元素的大小顺序遍历，LinkedHashSet按照元素的添加顺序遍历。</p>
<h3 id="1252-实现类的特点">12.5.2 实现类的特点</h3>
<p>（1）HashSet：</p>
<p>​	底层是HashMap实现。添加到HashSet的元素是作为HashMap的key，value是一个Object类型的常量对象PRESENT。</p>
<p>​	依赖于元素的hashCode()和equals()保证元素的不可重复，存储位置和hashCode()值有关，根据hashCode()来算出它在底层table数组中的[index]</p>
<p>（2）TreeSet</p>
<p>​	底层是TreeMap实现。添加到TreeSet的元素是作为TreeMap的key，value是一个Object类型的常量对象PRESENT。</p>
<p>​	依赖于元素的大小，要么是java.lang.Comparable接口compareTo(Object obj)，要么是java.util.Comparator接口的compare(Object o1, Object o2)来比较元素的大小。认为大小相等的两个元素就是重复元素。</p>
<p>（3）LinkedHashSet</p>
<p>​	底层是LinkedHashMap。添加到LinkedHashSet的元素是作为LinkedHashMap的key，value是一个Object类型的常量对象PRESENT。</p>
<p>​	LinkedHashSet是HashSet的子类，比父类多维护了元素的添加顺序。</p>
<p>​	当且仅当，你既想要元素不可重复，又要保证元素的添加顺序时，再使用它。</p>
<p>​</p>
<h2 id="126-map">12.6 Map</h2>
<h3 id="1261-map概述">12.6.1 Map概述</h3>
<p>用来存储键值对，映射关系的集合。所有的Map的key都不能重复。</p>
<p>键值对、映射关系的类型：Entry类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entry接口是Map接口的内部接口。所有的Map的键值对的类型都实现了这个接口。</span><br><span class="line">HashMap中的映射关系，是有一个内部类来实现Entry的接口，JDK1.7是一个叫做Entry的内部类实现Entry接口。</span><br><span class="line">JDK1.8是一个叫做Node的内部类实现Entry接口。</span><br><span class="line">TreeMap中的映射关系，是有一个内部类Entry来实现Entry的接口</span><br></pre></td></tr></table></figure>
<h3 id="1262-api">12.6.2 API</h3>
<p>（1）put(Object key, Object value)：添加一对映射关系</p>
<p>（2）putAll(Map m)：添加多对映射关系</p>
<p>（3）clear()：清空map</p>
<p>（4）remove(Object key)：根据key删除一对</p>
<p>（5）int size()：获取有效元素的对数</p>
<p>（6）containsKey(Object key)：是否包含某个key</p>
<p>（7）containsValue(Object value)：是否包含某个value</p>
<p>（8）Object  get(Object key)：根据key获取value</p>
<p>（9）遍历相关的几个方法</p>
<p>Collection  values()：获取所有的value进行遍历</p>
<p>Set keySet()：获取所有key进行遍历</p>
<p>Set entrySet()：获取所有映射关系进行遍历</p>
<h3 id="1263-map的实现类们的区别">12.6.3 Map的实现类们的区别</h3>
<p>（1）HashMap：</p>
<p>​	依据key的hashCode()和equals()来保证key是否重复。</p>
<p>​	key如果重复，新的value会替换旧的value。</p>
<p>​	hashCode()决定了映射关系在table数组中的存储的位置，index = hash(key.hashCode()) &amp; table.length-1</p>
<p>​	HashMap的底层实现：JDK1.7是数组+链表；JDK1.8是数组+链表/红黑树</p>
<p>（2）TreeMap</p>
<p>​	依据key的大小来保证key是否重复。key如果重复，新的value会替换旧的value。</p>
<p>​	key的大小依赖于，java.lang.Comparable或java.util.Comparator。</p>
<p>（3）LinkedHashMap</p>
<p>​	依据key的hashCode()和equals()来保证key是否重复。key如果重复，新的value会替换旧的value。</p>
<p>​	LinkedHashMap是HashMap的子类，比HashMap多了添加顺序</p>
<h3 id="1264-hashmap源码分析">12.6.4 HashMap源码分析</h3>
<h4 id="jdk16源码">JDK1.6源码：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//this.loadFactor加载因子，影响扩容的频率</span></span><br><span class="line">    <span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">//threshold阈值 = 容量 * 加载因子</span></span><br><span class="line">    <span class="comment">//threshold阈值，当size达到threhold时，考虑扩容</span></span><br><span class="line">    <span class="comment">//扩容需要两个条件同时满足：（1）size &gt;= threhold （2）table[index]！=null，即新映射关系要存入的位置非空</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line">    <span class="comment">//table是数组，</span></span><br><span class="line">    <span class="comment">//DEFAULT_INITIAL_CAPACITY：默认是16</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jdk17源码">JDK1.7源码：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//DEFAULT_INITIAL_CAPACITY：默认初始容量16</span></span><br><span class="line">  	<span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">      <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//校验initialCapacity合法性</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">      <span class="comment">//校验initialCapacity合法性                                       initialCapacity);</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      <span class="comment">//校验loadFactor合法性</span></span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line"><span class="comment">//加载因子，初始化为0.75</span></span><br><span class="line">      <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">      <span class="comment">// threshold 初始为初始容量                                  </span></span><br><span class="line">      threshold = initialCapacity;</span><br><span class="line">      init();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果table数组是空的，那么先创建数组</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            <span class="comment">//threshold一开始是初始容量的值</span></span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果key是null，单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对key的hashCode进行干扰，算出一个hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算新的映射关系应该存到table[i]位置，</span></span><br><span class="line">        <span class="comment">//i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//添加新的映射关系</span></span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">        <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);<span class="comment">//容量是等于toSize值的最接近的2的n次方</span></span><br><span class="line">		<span class="comment">//计算阈值 = 容量 * 加载因子</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//创建Entry[]数组，长度为capacity</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果key是null，直接存入[0]的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有重复的key，如果有重复的，就替换value</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//把新的映射关系存入[0]的位置，而且key的hash值用0表示</span></span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否需要库容</span></span><br><span class="line">        <span class="comment">//扩容：（1）size达到阈值（2）table[i]正好非空</span></span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            <span class="comment">//table扩容为原来的2倍，并且扩容后，会重新调整所有映射关系的存储位置</span></span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            <span class="comment">//新的映射关系的hash和index也会重新计算</span></span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//存入table中</span></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        <span class="comment">//原来table[i]下面的映射关系作为新的映射关系next</span></span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;<span class="comment">//个数增加</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>1、put(key,value)</p>
<p>（1）当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Entry</strong>的数组，这个HashMap$Entry类型是实现了java.util.<strong>Map.Entry</strong>接口</p>
<p>（2）特殊考虑：如果key为null，index直接是[0]</p>
<p>（3）在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p>
<p>（4）计算index = table.length-1 &amp; hash;</p>
<p>（5）如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p>
<p>（6）如果没有相同的，会把新的映射关系添加到链表的头，原来table[index]下面的Entry对象连接到新的映射关系的next中。</p>
<p>（7）添加之前先判断if(size &gt;= threshold  &amp;&amp;  table[index]!=null)如果该条件为true，会扩容</p>
<p>​	if(size &gt;= threshold  &amp;&amp;  table[index]!=null){</p>
<p>​		①会扩容</p>
<p>​		②会重新计算key的hash</p>
<p>​		③会重新计算index</p>
<p>​	}</p>
<p>2、get(key)</p>
<p>（1）计算key的hash值，用这个方法hash(key)</p>
<p>（2）找index = table.length-1 &amp; hash;</p>
<p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value</p>
<p>3、remove(key)</p>
<p>（1）计算key的hash值，用这个方法hash(key)</p>
<p>（2）找index = table.length-1 &amp; hash;</p>
<p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p>
<h4 id="jdk18源码">JDK1.8源码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">几个常量和变量：</span><br><span class="line">（<span class="number">1</span>）DEFAULT_INITIAL_CAPACITY：默认的初始容量 <span class="number">16</span></span><br><span class="line">（<span class="number">2</span>）MAXIMUM_CAPACITY：最大容量  <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br><span class="line">（<span class="number">3</span>）DEFAULT_LOAD_FACTOR：默认加载因子 <span class="number">0.75</span></span><br><span class="line">（<span class="number">4</span>）TREEIFY_THRESHOLD：默认树化阈值<span class="number">8</span>，当链表的长度达到这个值后，要考虑树化</span><br><span class="line">（<span class="number">5</span>）UNTREEIFY_THRESHOLD：默认反树化阈值<span class="number">6</span>，当树中的结点的个数达到这个阈值后，要考虑变为链表</span><br><span class="line">（<span class="number">6</span>）MIN_TREEIFY_CAPACITY：最小树化容量<span class="number">64</span></span><br><span class="line">		当单个的链表的结点个数达到<span class="number">8</span>，并且table的长度达到<span class="number">64</span>，才会树化。</span><br><span class="line">		当单个的链表的结点个数达到<span class="number">8</span>，但是table的长度未达到<span class="number">64</span>，会先扩容</span><br><span class="line">（<span class="number">7</span>）Node&lt;K,V&gt;[] table：数组</span><br><span class="line">（<span class="number">8</span>）size：记录有效映射关系的对数，也是Entry对象的个数</span><br><span class="line">（<span class="number">9</span>）<span class="keyword">int</span> threshold：阈值，当size达到阈值时，考虑扩容</span><br><span class="line">（<span class="number">10</span>）<span class="keyword">double</span> loadFactor：加载因子，影响扩容的频率</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">    <span class="comment">// all other fields defaulted，其他字段都是默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//目的：干扰hashCode值</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">	<span class="comment">//如果key是null，hash是0</span></span><br><span class="line">	<span class="comment">//如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或</span></span><br><span class="line">	<span class="comment">//		即就是用key的hashCode值高16位与低16位进行了异或的干扰运算</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	index = hash &amp; table.length-1</span></span><br><span class="line"><span class="comment">	如果用key的原始的hashCode值  与 table.length-1 进行按位与，那么基本上高16没机会用上。</span></span><br><span class="line"><span class="comment">	这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; <span class="comment">//数组</span></span><br><span class="line">	Node&lt;K,V&gt; p; <span class="comment">//一个结点</span></span><br><span class="line">	<span class="keyword">int</span> n, i;<span class="comment">//n是数组的长度   i是下标</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//tab和table等价</span></span><br><span class="line">	<span class="comment">//如果table是空的</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">		tab = resize();</span></span><br><span class="line"><span class="comment">		n = tab.length;*/</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12</span></span><br><span class="line"><span class="comment">		n = 16</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash</span></span><br><span class="line">	<span class="comment">//p = tab[i] 第1个结点</span></span><br><span class="line">	<span class="comment">//if(p==null) 条件满足的话说明 table[i]还没有元素</span></span><br><span class="line">	<span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="comment">//把新的映射关系直接放入table[i]</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">//newNode（）方法就创建了一个Node类型的新结点，新结点的next是null</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; </span><br><span class="line">		K k;</span><br><span class="line">		<span class="comment">//p是table[i]中第一个结点</span></span><br><span class="line">		<span class="comment">//if(table[i]的第一个结点与新的映射关系的key重复)</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">               e = p;<span class="comment">//用e记录这个table[i]的第一个结点</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;<span class="comment">//如果table[i]第一个结点是一个树结点</span></span><br><span class="line">               <span class="comment">//单独处理树结点</span></span><br><span class="line">               <span class="comment">//如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null</span></span><br><span class="line">               <span class="comment">//如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null</span></span><br><span class="line">			e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//table[i]的第一个结点不是树结点，也与新的映射关系的key不重复</span></span><br><span class="line">			<span class="comment">//binCount记录了table[i]下面的结点的个数</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">				<span class="comment">//如果p的下一个结点是空的，说明当前的p是最后一个结点</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">//把新的结点连接到table[i]的最后</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//如果binCount&gt;=8-1，达到7个时</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)&#123; <span class="comment">// -1 for 1st</span></span><br><span class="line">                           <span class="comment">//要么扩容，要么树化</span></span><br><span class="line">						treeifyBin(tab, hash);</span><br><span class="line">					&#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">				<span class="comment">//如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                   p = e;<span class="comment">//下一次循环，e=p.next，就类似于e=e.next，往链表下移动</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">		<span class="comment">//如果这个e不是null，说明有key重复，就考虑替换原来的value</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)&#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">			&#125;</span><br><span class="line">               afterNodeAccess(e);<span class="comment">//什么也没干</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//元素个数增加</span></span><br><span class="line">	<span class="comment">//size达到阈值</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line">           resize();<span class="comment">//一旦扩容，重新调整所有映射关系的位置</span></span><br><span class="line">	&#125;</span><br><span class="line">       afterNodeInsertion(evict);<span class="comment">//什么也没干</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;	</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab原来的table</span></span><br><span class="line">	<span class="comment">//oldCap：原来数组的长度</span></span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//oldThr：原来的阈值</span></span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;<span class="comment">//最开始threshold是0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//newCap，新容量</span></span><br><span class="line">	<span class="comment">//newThr：新阈值</span></span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//说明原来不是空数组</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//是否达到数组最大限制</span></span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)&#123;</span><br><span class="line">			<span class="comment">//newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制</span></span><br><span class="line">			<span class="comment">//新容量：32,64，...</span></span><br><span class="line">			<span class="comment">//oldCap &gt;= 初始容量16</span></span><br><span class="line">			<span class="comment">//新阈值重新算 = 24，48 ....</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">		&#125;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)&#123; <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//新容量是默认初始化容量16</span></span><br><span class="line">		<span class="comment">//新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12</span></span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;<span class="comment">//阈值赋值为新阈值12，24.。。。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建了一个新数组，长度为newCap，16，32,64.。。</span></span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;<span class="comment">//原来不是空数组</span></span><br><span class="line">		<span class="comment">//把原来的table中映射关系，倒腾到新的table中</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;<span class="comment">//e是table下面的结点</span></span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;<span class="comment">//把旧的table[j]位置清空</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果是最后一个结点</span></span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//重新计算e的在新table中的存储位置，然后放入</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果e是树结点</span></span><br><span class="line">					<span class="comment">//把原来的树拆解，放到新的table</span></span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					把原来table[i]下面的整个链表，重新挪到了新的table中</span></span><br><span class="line"><span class="comment">					*/</span></span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;	</span><br><span class="line"></span><br><span class="line">   <span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建一个新结点</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n, index; </span><br><span class="line">	Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="comment">//MIN_TREEIFY_CAPACITY：最小树化容量64</span></span><br><span class="line">	<span class="comment">//如果table是空的，或者  table的长度没有达到64</span></span><br><span class="line">       <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           resize();<span class="comment">//先扩容</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//用e记录table[index]的结点的地址</span></span><br><span class="line">           TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		do...while，把table[index]链表的Node结点变为TreeNode类型的结点</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                   hd = p;<span class="comment">//hd记录根结点</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">		</span><br><span class="line">           <span class="comment">//如果table[index]下面不是空</span></span><br><span class="line">           <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">               hd.treeify(tab);<span class="comment">//将table[index]下面的链表进行树化</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>1、添加过程</p>
<p>（1）当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Node</strong>的数组，这个HashMap$Node类型是实现了java.util.<strong>Map.Entry</strong>接口</p>
<p>（2）在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p>
<blockquote>
<p>JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16;</p>
</blockquote>
<p>（3）计算index = table.length-1 &amp; hash;</p>
<p>（4）如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p>
<p>（5）如果没有相同的，</p>
<p>①table[index]链表的长度没有达到8个，会把新的映射关系添加到链表的尾</p>
<p>②table[index]链表的长度达到8个，但是table.length没有达到64，会先对table进行扩容，然后再添加</p>
<p>③table[index]链表的长度达到8个，并且table.length达到64，会先把该分支进行树化，结点的类型变为TreeNode，然后把链表转为一棵红黑树</p>
<p>④table[index]本来就已经是红黑树了，那么直接连接到树中，可能还会考虑考虑左旋右旋以保证树的平衡问题</p>
<p>（6）添加完成后判断if(size &gt; threshold ){</p>
<p>​		①会扩容</p>
<p>​		②会重新计算key的hash</p>
<p>​		③会重新计算index</p>
<p>​	}</p>
<p>2、remove(key)</p>
<p>（1）计算key的hash值，用这个方法hash(key)</p>
<p>（2）找index = table.length-1 &amp; hash;</p>
<p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p>
<p>（4）如果table[index]下面原来是红黑树，结点删除后，个数小于等于6，会把红黑树变为链表</p>
<h3 id="1265-关于hashmap的面试问题">12.6.5 关于HashMap的面试问题</h3>
<p>1、HashMap的底层实现</p>
<blockquote>
<p>答：JDK1.7是数组+链表，JDK1.8是数组+链表/红黑树</p>
</blockquote>
<p>2、HashMap的数组的元素类型</p>
<blockquote>
<p>答：java.util.Map$Entry接口类型。</p>
<p>JDK1.7的HashMap中有内部类Entry实现Entry接口</p>
<p>JDK1.8的HashMap中有内部类Node和TreeNode类型实现Entry接口</p>
</blockquote>
<p>3、为什么要使用数组？</p>
<blockquote>
<p>答：因为数组的访问的效率高</p>
</blockquote>
<p>4、为什么数组还需要链表？或问如何解决hash或[index]冲突问题？</p>
<blockquote>
<p>答：为了解决hash和[index]冲突问题</p>
<p>（1）两个不相同的key的hashCode值本身可能相同</p>
<p>（2）两个hashCode不相同的key，通过hash(key)以及 hash &amp; table.length-1运算得到的[index]可能相同</p>
<p>那么意味着table[index]下可能需要存储多个Entry的映射关系对象，所以需要链表</p>
</blockquote>
<p>5、HashMap的数组的初始化长度</p>
<blockquote>
<p>答：默认的初始容量值是16</p>
</blockquote>
<p>6、HashMap的映射关系的存储索引index如何计算</p>
<blockquote>
<p>答：hash &amp; table.length-1</p>
</blockquote>
<p>7、为什么要使用hashCode()? 空间换时间</p>
<blockquote>
<p>答：因为hashCode()是一个整数值，可以用来直接计算index，效率比较高，用数组这种结构虽然会浪费一些空间，但是可以提高查询效率。</p>
</blockquote>
<p>8、hash()函数的作用是什么</p>
<blockquote>
<p>答：在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p>
<p>JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16; 因为这样可以使得hashCode的高16位信息也能参与到运算中来</p>
</blockquote>
<p>9、HashMap的数组长度为什么一定要是2的幂次方</p>
<blockquote>
<p>答：因为2的n次方-1的二进制值是前面都0，后面几位都是1，这样的话，与hash进行&amp;运算的结果就能保证在[0,table.length-1]范围内，而且是均匀的。</p>
</blockquote>
<p>10、HashMap 为什么使用 &amp;按位与运算代替%模运算？</p>
<blockquote>
<p>答：因为&amp;效率高</p>
</blockquote>
<p>11、HashMap的数组什么时候扩容？</p>
<blockquote>
<p>答：JDK1.7版：当要添加新Entry对象时发现（1）size达到threshold（2）table[index]!=null时，两个条件同时满足会扩容</p>
<p>JDK1.8版：当要添加新Entry对象时发现（1）size达到threshold（2）当table[index]下的结点个数达到8个但是table.length又没有达到64。两种情况满足其一都会导致数组扩容</p>
<p>而且数组一旦扩容，不管哪个版本，都会导致所有映射关系重新调整存储位置。</p>
</blockquote>
<p>12、如何计算扩容阈值(临界值)？</p>
<blockquote>
<p>答：threshold = capacity * loadfactor</p>
</blockquote>
<p>13、loadFactor为什么是0.75，如果是1或者0.1呢有什么不同？</p>
<blockquote>
<p>答：1的话，会导致某个table[index]下面的结点个数可能很长</p>
<p>0.1的话，会导致数组扩容的频率太高</p>
</blockquote>
<p>14、JDK1.8的HashMap什么时候树化？</p>
<blockquote>
<p>答：当table[index]下的结点个数达到8个但是table.length已经达到64</p>
</blockquote>
<p>15、JDK1.8的HashMap什么时候反树化？</p>
<blockquote>
<p>答：当table[index]下的树结点个数少于6个</p>
</blockquote>
<p>16、JDK1.8的HashMap为什么要树化？</p>
<blockquote>
<p>答：因为当table[index]下的结点个数超过8个后，查询效率就低下了，修改为红黑树的话，可以提高查询效率</p>
</blockquote>
<p>17、JDK1.8的HashMap为什么要反树化？</p>
<blockquote>
<p>答：因为因为当table[index]下树的结点个数少于6个后，使用红黑树反而过于复杂了，此时使用链表既简洁又效率也不错</p>
</blockquote>
<p>18、作为HashMap的key类型重写equals和hashCode方法有什么要求</p>
<p>​	（1）equals与hashCode一起重写</p>
<p>​	（2）重写equals()方法，但是有一些注意事项；</p>
<ul>
<li>自反性：x.equals(x)必须返回true。<br>
对称性：x.equals(y)与y.equals(x)的返回值必须相等。<br>
传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。<br>
一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。<br>
非null：x不是null，y为null，则x.equals(y)必须为false。</li>
</ul>
<p>​	（3）重写hashCode（）的注意事项</p>
<ul>
<li>如果equals返回true的两个对象，那么hashCode值一定相同，并且只要参与equals判断属性没有修改，hashCode值也不能修改；<br>
如果equals返回false的两个对象，那么hashCode值可以相同也可以不同；<br>
如果hashCode值不同的，equals一定要返回false；<br>
hashCode不宜过简单，太简单会导致冲突严重，hashCode也不宜过于复杂，会导致性能低下；</li>
</ul>
<p>19、为什么大部分 hashcode 方法使用 31？</p>
<blockquote>
<p>答：因为31是一个不大不小的素数</p>
</blockquote>
<p>20、请问已经存储到HashMap中的key的对象属性是否可以修改？为什么？</p>
<blockquote>
<p>答：如果该属性参与hashCode的计算，那么不要修改。因为一旦修改hashCode()已经不是原来的值。<br>
而存储到HashMap中时，key的hashCode()–&gt;hash()–&gt;hash已经确定了，不会重新计算。用新的hashCode值再查询get(key)/删除remove(key)时，算的hash值与原来不一样就不找不到原来的映射关系了。</p>
</blockquote>
<p>21、所以为什么，我们实际开发中，key的类型一般用String和Integer</p>
<blockquote>
<p>答：因为他们不可变。</p>
</blockquote>
<p>22、为什么HashMap中的Node或Entry类型的hash变量与key变量加final声明？</p>
<blockquote>
<p>答：因为不希望你修改hash和key值</p>
</blockquote>
<p>23、为什么HashMap中的Node或Entry类型要单独存储hash？</p>
<blockquote>
<p>答：为了在添加、删除、查找过程中，比较hash效率更高，不用每次重新计算key的hash值</p>
</blockquote>
<p>24、请问已经存储到HashMap中的value的对象属性是否可以修改？为什么？</p>
<blockquote>
<p>答：可以。因为我们存储、删除等都是根据key，和value无关。</p>
</blockquote>
<p>25、如果key是null是如何存储的？</p>
<blockquote>
<p>答：会存在table[0]中</p>
</blockquote>
<h2 id="127-集合框架图">12.7 集合框架图</h2>
<p><img src="/img/article/java/1560348912361.png" alt="1560348912361"></p>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/Java/13泛型/" data-toggle="tooltip" data-placement="top" title="[Java] Java（十三）泛型">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/Java/11常用类/" data-toggle="tooltip" data-placement="top" title="[Java] Java（十一）常用类">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                    <div class="reward">
                        <div class="reward-button">赏 <span class="reward-code"> 
                            <span class="alipay-code"> <img class="alipay-img" src="alipay_url"><b>支付宝打赏</b></span> 
                            <span class="wechat-code"> <img class="wechat-img" src="wechatpay_url"><b>微信打赏</b> </span>
                            </span></div>
                        <p class="reward-notice">赞赏一下</p>
                    </div>
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                    <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                    <!--  css & js -->
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#第十二章-集合"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">&#x7B2C;&#x5341;&#x4E8C;&#x7AE0; &#x96C6;&#x5408;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#121-概念"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">12.1 &#x6982;&#x5FF5;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#122-手动实现一些逻辑结构"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">12.2 &#x624B;&#x52A8;&#x5B9E;&#x73B0;&#x4E00;&#x4E9B;&#x903B;&#x8F91;&#x7ED3;&#x6784;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#123-collection"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">12.3  Collection</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1231-collection"><span class="toc-nav-number">1.3.1.</span> <span class="toc-nav-text">12.3.1 Collection</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1232-collection系列的集合的遍历"><span class="toc-nav-number">1.3.2.</span> <span class="toc-nav-text">12.3.2  Collection&#x7CFB;&#x5217;&#x7684;&#x96C6;&#x5408;&#x7684;&#x904D;&#x5386;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#124-list"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">12.4 List</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1241-list概述"><span class="toc-nav-number">1.4.1.</span> <span class="toc-nav-text">12.4.1 List&#x6982;&#x8FF0;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1242-list的api"><span class="toc-nav-number">1.4.2.</span> <span class="toc-nav-text">12.4.2 List&#x7684;API</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1243-listiterator-接口"><span class="toc-nav-number">1.4.3.</span> <span class="toc-nav-text">12.4.3 ListIterator &#x63A5;&#x53E3;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1244-list的实现类们的区别"><span class="toc-nav-number">1.4.4.</span> <span class="toc-nav-text">12.4.4 List&#x7684;&#x5B9E;&#x73B0;&#x7C7B;&#x4EEC;&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1245-源码分析"><span class="toc-nav-number">1.4.5.</span> <span class="toc-nav-text">12.4.5 &#x6E90;&#x7801;&#x5206;&#x6790;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1vector"><span class="toc-nav-number">1.4.5.1.</span> <span class="toc-nav-text">&#xFF08;1&#xFF09;Vector</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2arraylist源码分析"><span class="toc-nav-number">1.4.5.2.</span> <span class="toc-nav-text">&#xFF08;2&#xFF09;ArrayList&#x6E90;&#x7801;&#x5206;&#x6790;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3linkedlist源码分析"><span class="toc-nav-number">1.4.5.3.</span> <span class="toc-nav-text">&#xFF08;3&#xFF09;LinkedList&#x6E90;&#x7801;&#x5206;&#x6790;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#125-set"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text">12.5 Set</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1251-set概述"><span class="toc-nav-number">1.5.1.</span> <span class="toc-nav-text">12.5.1 Set&#x6982;&#x8FF0;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1252-实现类的特点"><span class="toc-nav-number">1.5.2.</span> <span class="toc-nav-text">12.5.2 &#x5B9E;&#x73B0;&#x7C7B;&#x7684;&#x7279;&#x70B9;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#126-map"><span class="toc-nav-number">1.6.</span> <span class="toc-nav-text">12.6 Map</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1261-map概述"><span class="toc-nav-number">1.6.1.</span> <span class="toc-nav-text">12.6.1 Map&#x6982;&#x8FF0;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1262-api"><span class="toc-nav-number">1.6.2.</span> <span class="toc-nav-text">12.6.2 API</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1263-map的实现类们的区别"><span class="toc-nav-number">1.6.3.</span> <span class="toc-nav-text">12.6.3 Map&#x7684;&#x5B9E;&#x73B0;&#x7C7B;&#x4EEC;&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1264-hashmap源码分析"><span class="toc-nav-number">1.6.4.</span> <span class="toc-nav-text">12.6.4 HashMap&#x6E90;&#x7801;&#x5206;&#x6790;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#jdk16源码"><span class="toc-nav-number">1.6.4.1.</span> <span class="toc-nav-text">JDK1.6&#x6E90;&#x7801;&#xFF1A;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#jdk17源码"><span class="toc-nav-number">1.6.4.2.</span> <span class="toc-nav-text">JDK1.7&#x6E90;&#x7801;&#xFF1A;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#jdk18源码"><span class="toc-nav-number">1.6.4.3.</span> <span class="toc-nav-text">JDK1.8&#x6E90;&#x7801;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1265-关于hashmap的面试问题"><span class="toc-nav-number">1.6.5.</span> <span class="toc-nav-text">12.6.5 &#x5173;&#x4E8E;HashMap&#x7684;&#x9762;&#x8BD5;&#x95EE;&#x9898;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#127-集合框架图"><span class="toc-nav-number">1.7.</span> <span class="toc-nav-text">12.7 &#x96C6;&#x5408;&#x6846;&#x67B6;&#x56FE;</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Java" title="Java">Java</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'rz'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/mochuangang">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 莫传刚 2020 
                    By <a href="http://www.mochuangang.com">欢迎来搞</a> | BigData
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=mochuangang&repo=mochuangang.github.io
&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://www.mochuangang.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://www.mochuangang.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
